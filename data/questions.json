{
  "questions": [
    {
      "question": "Какой фреймворк считается самым популярным в экосистеме JavaScript?",
      "options": ["Angular", "React", "Vue", "Svelte"],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "Какая компания создала React?",
      "options": ["Google", "Facebook (Meta)", "Amazon", "Netflix"],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "Как называется основная строительная единица React-приложений?",
      "options": ["Компоненты", "Контроллеры", "Виджеты", "Модули"],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "Как называется синтаксис, который описывает UI в React?",
      "options": ["HTML+", "JSX", "RML", "UIX"],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "Как данные обычно передаются в React-приложениях?",
      "options": [
        "От родителя к ребёнку",
        "От ребёнка к родителю",
        "В обе стороны",
        "Зависит от браузера"
      ],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "Как передать данные в дочерний компонент?",
      "options": ["Через state", "Через props", "Через события", "Через Ref"],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "Когда нужно использовать производное (derived) состояние?",
      "options": [
        "Когда состояние не должно вызывать повторный рендер",
        "Когда состояние зависит от API-запросов",
        "Когда состояние должно использоваться всеми компонентами",
        "Когда состояние можно вычислить из другого состояния"
      ],
      "correctOption": 3,
      "points": 30
    },
    {
      "question": "Что приводит к повторному рендеру компонента?",
      "options": [
        "Запуск эффекта",
        "Передача props",
        "Обновление состояния",
        "Изменение стилей"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "Как часто мы должны напрямую изменять DOM в React?",
      "options": [
        "Каждый раз при рендере",
        "Иногда",
        "Когда удобно",
        "Почти никогда"
      ],
      "correctOption": 3,
      "points": 20
    },
    {
      "question": "Когда нужно использовать callback-форму обновления состояния?",
      "options": [
        "Когда обновление слишком долгое",
        "Когда состояние большое",
        "Когда нужно оптимизировать рендер",
        "Когда новое состояние зависит от предыдущего"
      ],
      "correctOption": 3,
      "points": 30
    },
    {
      "question": "Когда вызывается функция, переданная в useState при инициализации?",
      "options": [
        "При каждом рендере",
        "Каждый раз при обновлении state",
        "Только при первом рендере",
        "При размонтировании компонента"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "Какой хук используют для выполнения API-запроса при первом рендере?",
      "options": ["useMemo", "useState", "useEffect", "useRef"],
      "correctOption": 2,
      "points": 10
    },
    {
      "question": "Какие переменные должны быть в массиве зависимостей useEffect?",
      "options": [
        "Никакие",
        "Только props",
        "Все значения, используемые внутри эффекта",
        "Только state"
      ],
      "correctOption": 2,
      "points": 30
    },
    {
      "question": "Эффект (useEffect) всегда выполняется при первом рендере.",
      "options": ["Да", "Нет", "Зависит от зависимостей", "Никогда"],
      "correctOption": 0,
      "points": 30
    },
    {
      "question": "Когда выполняется эффект без массива зависимостей?",
      "options": [
        "Только при монтировании",
        "Только при размонтировании",
        "Только при первом обновлении",
        "При каждом рендере"
      ],
      "correctOption": 3,
      "points": 20
    },
    {
      "question": "Какой хук используется для хранения значения между рендерами?",
      "options": ["useRef", "useStore", "useMemo", "useState"],
      "correctOption": 0,
      "points": 20
    },
    {
      "question": "Какой хук подходит для сложной логики обновления состояния?",
      "options": ["useEffect", "useReducer", "useMemo", "useRef"],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "Что произойдёт при непосредственном изменении объекта внутри useState без setState?",
      "options": [
        "Компонент обновится",
        "Компонент зависнет",
        "Рендера не будет",
        "Произойдёт ошибка"
      ],
      "correctOption": 2,
      "points": 20
    },
    {
      "question": "Что делает useMemo?",
      "options": [
        "Кэширует вычисления",
        "Кэширует компоненты",
        "Оптимизирует DOM-дерево",
        "Заменяет useEffect"
      ],
      "correctOption": 0,
      "points": 20
    },
    {
      "question": "Что делает useCallback?",
      "options": [
        "Кэширует функции",
        "Кэширует объекты",
        "Оптимизирует рендер DOM",
        "Создаёт новый state"
      ],
      "correctOption": 0,
      "points": 20
    },
    {
      "question": "Что хранит useRef?",
      "options": [
        "Массив зависимостей",
        "Ссылку на DOM или произвольное значение",
        "Состояние компонента",
        "Кэш вызовов функций"
      ],
      "correctOption": 1,
      "points": 10
    },
    {
      "question": "Когда вызывается функция очистки (cleanup) в useEffect?",
      "options": [
        "До каждого нового вызова эффекта",
        "После каждого рендера",
        "Только при размонтировании",
        "Никогда"
      ],
      "correctOption": 0,
      "points": 20
    },
    {
      "question": "Что произойдёт, если в dependency array указать пустой массив?",
      "options": [
        "Эффект будет выполняться при каждом рендере",
        "Эффект выполнится один раз при монтировании",
        "Эффект не выполнится вообще",
        "Эффект будет выполняться каждый раз, когда обновится state"
      ],
      "correctOption": 1,
      "points": 20
    },
    {
      "question": "Как лучше всего передать функцию из родителя в ребёнка?",
      "options": ["Через props", "Через контекст", "Через state", "Никак"],
      "correctOption": 0,
      "points": 10
    },
    {
      "question": "Когда стоит использовать Context?",
      "options": [
        "Когда нужно передать данные нескольким уровням компонентов",
        "Когда компонент слишком большой",
        "Когда мало state",
        "Когда нужно ускорить работу приложения"
      ],
      "correctOption": 0,
      "points": 30
    }
  ]
}
